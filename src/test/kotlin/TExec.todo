class TExec {
    // UNDERSCORE

    @Test
    fun gg_01_und() {
        val out = test(
            """
            val _ = 10
            println(_)
        """
        )
        assert(out == "anon : (lin 3, col 21) : access error : cannot access \"_\"") { out }
    }
    @Test
    fun gg_02_und() {
        val out = test(
            """
            do {
                val _ = println(10)
            }
            do {
                val _ = println(20)
            }
            println(:ok)
        """
        )
        assert(out == "10\n20\n:ok\n") { out }
    }
    @Test
    fun gg_03_und() {
        val out = test("""
            val _ = 10
            val _ = 10
            println(:ok)
        """)
        assert(out == ":ok\n") { out }
    }

    // TUPLE

    @Test
    fun cc_tuple11_copy() {
        val out = all("""
            val t1 = [1,2,3]
            val t2 = copy(t1)
            val t3 = t1
            set t1[2] = 999
            set t2[0] = 10
            println(t1)
            println(t2)
            println(t3)
        """, true)
        assert(out == "[1,2,999]\n[10,2,3]\n[1,2,999]\n") { out }
    }
    @Test
    fun cc_tuple12_free_copy() {
        val out = all("""
            var f
            set f = func (v) {
                ;;println(v)
                if v > 0 {
                    copy([f(v - 1)])
                } else {
                    0
                }
            }
            println(f(3))
        """, true)
        assert(out == "[[[0]]]\n") { out }
    }
    @Test
    fun cc_tuple13_copy_out() {
        val out = all("""
            val out = do {
                val ins = [1,2,3]
                copy(ins)
            }
            println(out)
        """, true)
        assert(out == "[1,2,3]\n") { out }
    }

    @Test
    fun cc_tuple21_scope_copy() {
        val out = all("""
            var x = [1,2,3]
            do {
                val y = copy(x)
                do {
                    set x = y
                }
            }
            println(x)
        """, true)
        assert(out == "anon : (lin 6, col 25) : set error : incompatible scopes\n" +
                ":error\n") { out }
    }
    @Test
    fun cc_tuple22_scope_copy() {
        val out = all("""
            var x = [1,2,3]
            do {
                val y = copy(x)
                do {
                    set x = copy(y)
                }
            }
            println(x)
        """, true)
        assert(out == "[1,2,3]\n") { out }
    }
    @Test
    fun cc_tuple23_scope_copy() {
        val out = all("""
            var v
            do {
                var x = [1,2,3]
                do {
                    val y = copy(x)
                    do {
                        set x = copy(y)
                        ;;`printf(">>> %d\n", ceu_mem->x.Dyn->hld_type);`
                        set v = x       ;; err
                    }
                }
            }
            println(v)
        """, true)
        assert(out == "anon : (lin 10, col 29) : set error : incompatible scopes\n" +
                ":error\n") { out }
    }

    // DICT

    @Test
    fun dd_dict6_copy() {
        val out = all("""
            val t1 = @[]
            set t1[:x] = 1
            val t2 = t1
            val t3 = copy(t1)
            set t1[:y] = 2
            set t3[:y] = 20
            println(t1)
            println(t2)
            println(t3)
        """)
        assert(out == "@[(:x,1),(:y,2)]\n@[(:x,1),(:y,2)]\n@[(:x,1),(:y,20)]\n") { out }
    }

    // VECTOR

    @Test
    fun vector10_pop_acc() {
        val out = all("""
            val v = #[1,2,3]
            val x = export [] {
                val i = v[#v - 1]
                set v[#v - 1] = nil
                i
            }
            println(x, #v)
        """, true)
        assert(out == "3\t2\n") { out }
    }
    @Test
    fun vector12_copy() {
        val out = all("""
            val t1 = #[]        ;; [1,2]
            set t1[#t1] = 1
            val t2 = t1         ;; [1,2]
            val t3 = copy(t1)   ;; [1,20]
            set t1[#t1] = 2
            set t3[#t3] = 20
            println(t1)
            println(t2)
            println(t3)
        """, true)
        assert(out == "#[1,2]\n#[1,2]\n#[1,20]\n") { out }
    }

    // GROUP

    @Test
    fun group1() {
        val out = all("""
            export [a] {
                val a = 10
            }
            export [x] {
                var x
                set x = a
            }
            print(x)
        """)
        assert(out == "10") { out }
    }
    @Test
    fun group2_err() {
        val out = all("""
            export [] {
                var a       ;; invisible
                set a = 10
            }
            var x
            set x = a
            print(x)
        """)
        assert(out == "anon : (lin 7, col 21) : access error : variable \"a\" is not declared") { out }
    }
    @Test
    fun group3() {
        val out = all("""
            val x = export [] {
                val a = []
                a
            }
            print(x)
        """)
        assert(out == "[]") { out }
    }
    @Test
    fun export4() {
        val out = all("""
            export [aaa] {
                val aaa = 10
            }
            export [bbb] {
                val bbb = 20
            }
            println(aaa,bbb)
        """)
        assert(out == "10\t20\n") { out }
    }
    @Test
    fun export6() {
        val out = all("""
            export [f] {
                val v = []
                val f = func () {
                    v
                }
                ;;println(v, f)
            }
            do {
                val x = f
                nil
            }
            println(:ok)
        """)
        assert(out == ":ok\n") { out }
    }
    @Test
    fun export7() {
        val out = all("""
            do {
                export [f] {
                    val v = []
                    val f = func () {
                        v
                    }
                    ;;println(v, f)
                }
                do {
                    val x = f
                    nil
                }
                println(:ok)
            }
        """)
        assert(out == ":ok\n") { out }
    }

    @Test
    fun todo_op_id2() {
        val out = all("""
            set (+) = (-)
            println((+)(10,4))
        """)
        assert(out == "6\n") { out }
    }

    // TYPE

    @Test
    fun tags15() {
        val out = all("""
            val t = tags([], :x, true)
            val s = copy(t)
            println(s)
        """)
        assert(out == ":x []\n") { out }
    }

    // CLOSURE / ESCAPE / FUNC / UPVALS

    @Ignore
    @Test
    fun todo_clo24_copy() {
        val out = all("""
            var f = func (^a) {
                func () {
                    ^^a
                }
            }
            var g = do {
                var t = [1]
                var i = copy(f(t))
                set t[0] = 10
                move(i)
            }
            println(g())
        """)
        assert(out == "[1]\n") { out }
    }

    // POLY
    /*
    @Test
    fun vv_01_poly_ret_type() {
        val out = all("""
            poly var min
            poly set min :number = 1
            poly set min :char   = 'a'
            var n :number = min
            var c :char   = min
            println(min)
            println(n, c)
        """)
        assert(out == "1\t'a'\n") { out }
    }
    @Test
    fun vv_02_poly_ret_tag() {
        val out = all("""
            poly var min
            poly set min :Nat  = 1
            poly set min :Char = 'a'
            var n :Nat  = min
            var c :Char = min
            println(n, c)
        """)
        assert(out == "[1,'a']\n") { out }
    }
    @Test
    fun vv_02_poly_func_ret() {
        val out = all("""
            poly var read
            poly set read = func () -> :Nat {
                return 1
            }
            poly func read () -> :Char {
                return 'a'
            }
            var n :Nat  = read()
            var c :Char = read()
            println(n, c)
        """, true)
        assert(out == "[1,'a']\n") { out }
    }
    @Test
    fun vv_03_poly_func_args_one() {
        val out = all("""
            poly var f
            poly set f = func (v:Nat) {
                println(:Nat, v)
            }
            poly func f (v:Char) {
                println(:Char, v)
            }
            f(:Nat  [1])
            f(:Char ['a'])
        """, true)
        assert(out == ":Nat\t[1]\n:Char\t['a']\n") { out }
    }
    @Test
    fun vv_04_poly_func_args_one() {
        val out = all("""
            poly var f
            poly func f (v:number) {
                println(:number, v)
            }
            poly set f = func (v:char) {
                println(:char, v)
            }
            f(1)
            f('a')
        """, true)
        assert(out == ":number\t1\n:char\t'a'\n") { out }
    }
    @Test
    fun vv_04_poly_func_args_multi() {
        val out = all("""
            poly var f
            poly func f (x:number, y:number) {
                println(:number, x, :number, y)
            }
            poly set f = func (x:number, y:char) {
                println(:number, x, :char, y)
            }
            f(1, 'a')
            f(1, 2)
        """, true)
        assert(out == ":number\t1\t:char\t'a'\n:number\t1\t:number\t1\n") { out }
    }
    @Test
    fun vv_05_poly_set_nopoly_err() {
        val out = all("""
            var min
            poly set min :number = 1
        """)
        assert(out == "1\t'a'\n") { out }
    }
    */
}
