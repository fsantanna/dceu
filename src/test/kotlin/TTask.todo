class TTask {



    // BCAST / SCOPE

    @Test
    fun ee_bcast_in4() {
        val out = ceu.all(
            """
            var T
            set T = task (v) {
                yield(nil)
                println(v)
            }
            var t1
            set t1 = spawn T (1)
            do {
                var t2
                set t2 = spawn T (2)
                broadcast in :local, nil
            }
        """
        )
        assert(out == "2\n") { out }
    }

    @Test
    fun ee_19_bcast_copy() {
        val out = all("""
            val T = task () {
                yield(nil)
                val v = copy(evt)
                println(v)
            }
            spawn T()
            broadcast [1,2,3]
        """)
        assert(out == "[1,2,3]\n") { out }
    }

    // POOL
    // COROS ITERATOR

    @Test
    fun ff_pool1() {
        val out = all("""
            var ts
            set ts = tasks()
            println(type(ts))
            var T
            set T = task (v) {
                println(v)
                yield(nil)
                println(evt)
            }
            do {
                spawn in ts, T(1)
            }
             broadcast 2
        """)
        assert(out == ":x-tasks\n1\n2\n") { out }
    }
    @Test
    fun ff_pool2_leak() {
        val out = all("""
            var T
            set T = task () {
                pass [1,2,3]
                yield(nil)
            }
            var ts
            set ts = tasks()
            spawn in ts, T(1)
            spawn in ts, T(2)
            println(1)
        """)
        assert(out == "1\n") { out }
    }
    @Test
    fun ff_pool4_defer() {
        val out = all("""
            var T
            set T = task (v) {
                defer {
                    println(v)
                }
                yield(nil)
            }
            var ts
            set ts = tasks()
            spawn in ts, T(1)
            spawn in ts, T(2)
            println(0)
        """)
        assert(out == "0\n1\n2\n") { out }
    }
    @Test
    fun ff_pool5_scope() {
        val out = all("""
            do {
                var ts
                set ts = tasks()
                var T
                set T = task (v) {
                    println(v)
                    val v' = yield(nil)
                    println(v')
                }
                spawn in ts, T(1)
            }
             broadcast 2
        """)
        assert(out == "1\n") { out }
    }
    @Test
    fun ff_pool6_terminate() {
        val out = all("""
            do {
                var ts
                set ts = tasks()
                var T
                set T = task (v) {
                    println(v)
                }
                spawn in ts, T(1)
                loop in :tasks ts, t {
                    throw(1)    ;; never reached
                }
            }
            broadcast 2
        """)
        assert(out == "1\n") { out }
    }
    @Test
    fun ff_pool7_leak() {
        val out = all("""
            var T
            set T = task () {
                yield(nil)
            }
            var ts
            set ts = tasks()
            spawn in ts, T()
            println(1)
        """)
        assert(out == "1\n") { out }
    }
    @Test
    fun ff_pool8_err() {
        val out = all("""
            loop in :tasks nil, x {
                10
            }
        """)
        assert(out == "anon : (lin 3, col 17) : expression error : innocuous expression") { out }
    }
    @Test
    fun ff_pool8a_err() {
        val out = all("""
            loop in :tasks nil, x {
                pass nil
            }
        """)
        assert(out == "anon : (lin 2, col 28) : loop error : expected tasks\n:error\n") { out }
    }
    @Test
    fun ff_pool9_term() {
        val out = all("""
            var T = task () {
                yield(nil)
            }
            var ts = tasks()
            spawn in ts, T()
            loop in :tasks ts, xxx {
                println(1)
                broadcast 1
            }
            println(2)
        """)
        assert(out == "1\n2\n") { out }
    }
    @Test
    fun ff_pool10_term() {
        val out = all("""
            var T
            set T = task () {
                yield(nil)
                yield(nil)
            }
            var ts = tasks()
            spawn in ts, T()
            loop in :tasks ts, xxx {
                println(1)
                broadcast 1
                loop in :tasks ts, yyy {
                    println(2)
                }
            }
            println(3)
        """)
        assert(out == "1\n2\n3\n") { out }
    }
    @Test
    fun ff_pool11_plain() {
        val out = all("""
            var T = task () { yield(nil) }
            var ts = tasks()
            spawn in ts, T()
            var yyy
            loop in :tasks ts, xxx {
                set yyy = xxx
            }
            println(status(detrack(yyy)))
        """)
        //assert(out == "anon : (lin 9, col 21) : set error : incompatible scopes\n") { out }
        assert(out == "anon : (lin 7, col 21) : set error : incompatible scopes\n:error\n") { out }
        //assert(out == ":yielded\n") { out }
    }
    @Test
    fun ff_pool11_move() {
        val out = all("""
            var T = task () { yield(nil) }
            var ts = tasks()
            spawn in ts, T()
            var yyy
            loop in :tasks ts, xxx {
                set yyy = move(xxx)
            }
            println(status(detrack(yyy)))
        """)
        //assert(out == "anon : (lin 9, col 21) : set error : incompatible scopes\n") { out }
        //assert(out == "anon : (lin 9, col 21) : set error : incompatible scopes\n:error\n") { out }
        assert(out == ":yielded\n") { out }
    }
    @Test
    fun ff_pool11_check() {
        val out = all("""
            var T = task () { yield(nil) }
            var ts = tasks()
            spawn in ts, T()
            loop in :tasks ts, xxx {
                println(detrack(xxx) == detrack(xxx))
            }
        """)
        assert(out == "true\n") { out }
    }
    @Test
    fun ff_pool11_copy() {
        val out = all("""
            var T = task () { yield(nil) }
            var ts = tasks()
            spawn in ts, T()
            var yyy
            loop in :tasks ts, xxx {
                set yyy = copy(xxx)
            }
            println(status(detrack(yyy)))
        """)
        //assert(out == "anon : (lin 9, col 21) : set error : incompatible scopes\n") { out }
        //assert(out == "anon : (lin 9, col 21) : set error : incompatible scopes\n:error\n") { out }
        assert(out == ":yielded\n") { out }
    }
    @Test
    fun ff_pool11a_err_scope() {
        val out = all("""
            var T
            set T = task () { yield(nil) }
            var ts
            set ts = tasks()
            spawn in ts, T()
            var yyy
            loop in :tasks ts, xxx {
                set yyy = copy(xxx)
            }
            broadcast nil
            println(detrack(yyy))
        """)
        //assert(out == "anon : (lin 9, col 21) : set error : incompatible scopes\n") { out }
        //assert(out == "anon : (lin 9, col 21) : set error : incompatible scopes\n:error\n") { out }
        assert(out == "nil\n") { out }
    }
    @Test
    fun ff_pool12_bcast() {
        val out = all("""
            var T = task () { yield(nil); println(:ok) }
            var ts = tasks()
            spawn in ts, T()
            loop in :tasks ts, xxx {
                broadcast in detrack(xxx), nil
            }
        """)
        assert(out == ":ok\n") { out }
    }
    @Test
    fun ff_pool12_err_scope() {
        val out = ceu.all(
            """
            var T
            set T = task () { yield(nil) }
            var ts
            set ts = tasks()
            spawn in ts, T()
            loop in :tasks ts, xxx {
                var yyy
                loop in :tasks ts, zzz {
                    set yyy = copy(zzz)
                    println(status(detrack(yyy)))
                }
                println(status(detrack(yyy)))
                set yyy = xxx
            }
        """
        )
        //assert(out == "anon : (lin 10, col 25) : set error : incompatible scopes\n") { out }
        //assert(out == "anon : (lin 10, col 25) : set error : incompatible scopes\n:error\n") { out }
        assert(out == ":yielded\n:yielded\n") { out }
    }
    @Test
    fun ff_pool13_scope() {
        val out = ceu.all(
            """
            var T
            set T = task () { yield(nil) }
            var ts
            set ts = tasks()
            spawn in ts, T()
            loop in :tasks ts, xxx {
                var yyy
                loop in :tasks ts, zzz {
                    pass nil
                }
                set yyy = xxx
                ;;pass nil ;; otherwise scope err for yyy/xxx
            }
            println(1)
        """
        )
        assert(out == "1\n") { out }
    }
    @Test
    fun ff_poolX_scope() {
        val out = ceu.all(
            """
            var T
            set T = task () { yield(nil) }
            var ts
            set ts = tasks()
            spawn in ts, T()
            loop in :tasks ts, xxx {
                pass xxx
            }
            println(1)
        """
        )
        //assert(out == "anon : (lin 7, col 13) : set error : incompatible scopes\n:error\n") { out }
        assert(out == "1\n") { out }
    }
    @Test
    fun ff_pool14_max_err() {
        val out = ceu.all(
            """
            tasks(0)
        """
        )
        assert(out == "anon : (lin 2, col 13) : tasks(0)\n" +
                "tasks error : expected positive number\n" +
                ":error\n") { out }
    }
    @Test
    fun ff_pool15_max_err() {
        val out = ceu.all(
            """
            tasks(nil)
        """
        )
        assert(out == "anon : (lin 2, col 13) : tasks(nil)\n" +
                "tasks error : expected positive number\n" +
                ":error\n") { out }
    }
    @Test
    fun ff_pool16_max() {
        val out = ceu.all(
            """
            var ts = tasks(1)
            var T = task () { yield(nil) }
            var ok1 = spawn in ts, T()
            var ok2 = spawn in ts, T()
            broadcast nil
            var ok3 = spawn in ts, T()
            var ok4 = spawn in ts, T()
            println(ok1, ok2, ok3, ok4)
        """
        )
        assert(out == "true\tfalse\ttrue\tfalse\n") { out }
    }
    @Test
    fun ff_pool17_term() {
        val out = ceu.all(
            """
            var ts
            set ts = tasks(2)
            var T
            set T = task (v) {
                println(10)
                defer {
                    println(20)
                    println(30)
                }
                do { var ok1; set ok1=false; loop until ok1 { yield(nil;) if type(evt)/=:x-task { set ok1=true } else { nil } } }
                ;;yield(nil)
                if v {
                    do { var ok; set ok=false; loop until ok { yield(nil;) if type(evt)/=:x-task { set ok=true } else { nil } } }
                    ;;yield(nil)
                } else {
                    nil
                }
            }
            println(0)
            spawn in ts, T(false)
            spawn in ts, T(true)
            println(1)
            broadcast @[]
            println(2)
            broadcast @[]
            println(3)
        """
        )
        assert(out == "0\n10\n10\n1\n20\n30\n2\n20\n30\n3\n") { out }
    }
    @Test
    fun ff_pool19_throw() {
        val out = ceu.all(
            """
            var T
            set T = task (v) {
                spawn task () {
                    println(v)
                    yield(nil)
                    println(v)
                } ()
                loop { yield(nil) }
            }
            spawn T(1)
            spawn T(2)
            broadcast nil
        """
        )
        assert(out == "1\n2\n1\n2\n") { out }
    }
    @Test
    fun ff_pool20_throw() {
        val out = ceu.all(
            """
            var ts
            set ts = tasks(2)
            var T
            set T = task (v) {
                defer {
                    println(v)
                }
                catch err==:ok {
                    spawn task () {
                        yield(nil)
                        if v == 1 {
                            throw(:ok)
                        } else {
                            nil
                        }
                        loop { yield(nil) }
                    } ()
                    loop { yield(nil) }
                }
                println(v)
            }
            spawn in ts, T(1)
            spawn in ts, T(2)
            broadcast nil
            broadcast nil
            println(999)
        """
        )
        assert(out == "1\n1\n999\n2\n") { out }
    }
    @Test
    fun ff_pool21_throw() {
        val out = ceu.all(
            """
            var ts
            set ts = tasks(2)
            var T
            set T = task (v) {
                defer {
                    println(v)
                }
                catch err==:ok {
                    spawn task () {
                        yield(nil)
                        if v == 2 {
                            throw(:ok)
                        } else {
                            nil
                        }
                        loop { yield(nil) }
                    } ()
                    loop { yield(nil) }
                }
                println(v)
            }
            spawn in ts, T(1)
            spawn in ts, T(2)
            broadcast nil
            broadcast nil
            println(999)
        """
        )
        assert(out == "2\n2\n999\n1\n") { out }
    }
    @Test
    fun ff_pool22() {
        val out = all("""
            var ts
            set ts = tasks()
            println(type(ts))
            var T
            set T = task (v) {
                set task.pub = v
                val v' = yield(nil)
            }
            spawn in ts, T(1)
            spawn in ts, T(2)
            
            loop in :tasks ts, t1 {
                loop in :tasks ts, t2 {
                    println(detrack(t1).pub, detrack(t2).pub)
                }
            }
             broadcast 2
        """)
        assert(out == ":x-tasks\n1\t1\n1\t2\n2\t1\n2\t2\n") { out }
    }
    @Test
    fun ff_pool23_throw() {
        val out = ceu.all(
            """
            spawn (task () {
                catch err==:ok {
                    spawn task () {
                        yield(nil)
                        throw(:ok)
                    } ()
                    loop { yield(nil) }
                }
            })()
            broadcast nil
            println(999)
        """
        )
        assert(out == "999\n") { out }
    }
    @Test
    fun ff_pool24_term() {
        val out = ceu.all(
            """
            var T
            set T = task () {
                yield(nil)
                throw(nil)
            }
            spawn T()
            spawn T()
            broadcast @[]
        """
        )
        assert(out == "anon : (lin 9, col 13) : broadcast @[]\n" +
                "anon : (lin 5, col 17) : throw(nil)\n" +
                "throw error : uncaught exception\n" +
                "nil\n") { out }
    }
    @Test
    fun todo_pool25_valgrind() {
        val out = ceu.all(
            """
            var ts
            set ts = tasks(1)
            var T
            set T = task () { yield(nil) }
            var ok1
            set ok1 = spawn in ts, T()
            broadcast nil
            var ok2
            set ok2 = spawn in ts, T()
            println(ok1, ok2)
        """
        )
        assert(out == "true\tfalse\ttrue\tfalse\n") { out }
    }
    @Test
    fun todo_ff_pool26_reuse_awake() {
        val out = ceu.all(
            """
            var T = task (n) {
                set task.pub = n
                yield(nil)
                ;;println(:awake, evt, n)
                loop until evt == n {
                    yield(nil)
                }
                ;;println(:term, n)
            }
            var ts = tasks(2)
            spawn in ts, T(1)
            spawn in ts, T(2)
            loop in :tasks ts, t {
                println(:t, detrack(t).pub)
                ;;println(:bcast1)
                broadcast 2         ;; opens hole for 99 below
                ;;println(:bcast2)
                var ok = spawn in ts, T(99)     ;; must not fill hole b/c ts in the stack
                println(ok)
            }
            ;;;
            println("-=-=-=-")
            loop in :tasks ts, x {
                println(:t, detrack(x).pub)
            }
            ;;;
        """
        )
        assert(out == "1\nfalse\n") { out }
    }
    @Test
    fun ff_pool27_term() {
        val out = all("""
            var T = task () {
                spawn task () {
                    yield(nil)
                }()
                yield(nil)
            }
            var ts = tasks()
            spawn in ts, T()
            spawn in ts, T()
            spawn task () {
                loop in :tasks ts, xxx {
                    println(1)
                    broadcast 1
                }
            } ()
            println(2)
        """)
        assert(out == "1\n2\n") { out }
    }
    @Test
    fun ff_pool28_val() {
        val out = all("""
            val T = task () {
                yield(nil)
            }
            var ts = tasks()
            spawn in ts, T()
            loop in :tasks ts, trk {
                val tsk = detrack(trk)
                broadcast nil
            }
            println(:ok)
        """)
        assert(out == "anon : (lin 8, col 17) : declaration error : incompatible scopes\n" +
                ":error\n") { out }
    }
    @Test
    fun ff_pool29_val() {
        val out = all("""
            val T = task () {
                yield(nil)
            }
            var ts = tasks()
            spawn in ts, T()
            loop in :tasks ts, trk {
                val      tsk1 = detrack(trk)
                val :tmp tsk2 = detrack(trk)
            }
            println(:ok)
        """)
        assert(out == ":ok\n") { out }
        //assert(out == "anon : (lin 8, col 17) : declaration error : incompatible scopes\n" +
        //        ":error\n") { out }
    }
    @Test
    fun ff_pool30_scope() {
        val out = all("""
            var T = task () { yield(nil) }
            var ts = tasks()
            spawn in ts, T()
            loop in :tasks ts, xxx {
                do {
                    val zzz = detrack(xxx)
                    nil
                }
            }
            println(:ok)
        """)
        assert(out == ":ok\n") { out }
    }

    // EVT

    @Test
    fun gg_evt_hld1_err() {
        val out = ceu.all(
            """
            var tk
            set tk = task (xxx) {
                yield(nil)
                do {
                    val xxx' = evt
                    nil
                }
            }
            var co = spawn(tk)()
            broadcast []
            println(`:number CEU_GC.free`)
        """
        )
        assert(out == "1\n") { out }
        //assert(out == "anon : (lin 9, col 13) : broadcast []\n" +
        //        "anon : (lin 4, col 27) : invalid evt : cannot expose dynamic alien\n:error\n") { out }
        //assert(out == "anon : (lin 9, col 13) : broadcast []\n" +
        //        "anon : (lin 5, col 17) : declaration error : incompatible scopes\n" +
        //        ":error\n") { out }
    }
    @Test
    fun gg_evt_hld1_1_err() {
        val out = ceu.all(
            """
            var tk
            set tk = task (xxx) {
                yield(nil)
                do {
                    val xxx' = evt[0]
                }
            }
            spawn (tk) ()
            broadcast [[]]
            println(`:number CEU_GC.free`)
        """
        )
        //assert(out == "anon : (lin 8, col 13) : broadcast [[]]\n" +
        //        "anon : (lin 4, col 31) : invalid index : cannot expose dynamic alien field\n:error\n") { out }
        assert(out == "2\n") { out }
        //assert(out == "anon : (lin 8, col 13) : broadcast [[]]\n" +
        //        "anon : (lin 5, col 17) : declaration error : incompatible scopes\n" +
        //        ":error\n") { out }
    }
    @Test
    fun gg_evt_hld2_err() {
        val out = ceu.all(
            """
            var tk
            set tk = task (xxx) {
                yield(nil)
                do {
                    val xxx' = evt
                    nil
                }
            }
            var co = spawn (tk) (1)
            broadcast []
            println(`:number CEU_GC.free`)
        """
        )
        assert(out == "1\n") { out }
        //assert(out == "anon : (lin 10, col 14) : broadcast []\n" +
        //        "anon : (lin 5, col 27) : invalid evt : cannot expose dynamic alien\n:error\n") { out }
        //assert(out == "anon : (lin 9, col 13) : broadcast []\n" +
        //        "anon : (lin 5, col 17) : declaration error : incompatible scopes\n" +
        //        ":error\n") { out }
    }
    @Test
    fun gg_evt_hld2a() {
        val out = ceu.all(
            """
            var tk
            set tk = task (xxx) {
                yield(nil)
                do {
                    val xxx' = evt
                }
                    yield(nil)
            }
            var co = spawn (tk)(1)
            broadcast []
            println(`:number CEU_GC.free`)
        """
        )
        assert(out == "1\n") { out }
        //assert(out == "anon : (lin 10, col 14) : broadcast []\n" +
        //        "anon : (lin 5, col 27) : invalid evt : cannot expose dynamic alien\n:error\n") { out }
        //assert(out == "anon : (lin 9, col 13) : broadcast []\n" +
        //        "anon : (lin 5, col 17) : declaration error : incompatible scopes\n" +
        //        ":error\n") { out }
    }
    @Test
    fun gg_evt_hld3() {
        val out = ceu.all(
        """
            var fff
            set fff = func (x) { x }
            spawn task () {
                yield(nil)
                loop until evt[:type]==:x {
                    yield(nil)
                }
                println(99)
            }()
            println(1)
            broadcast @[(:type,:y)]
            println(2)
            broadcast @[(:type,:x)]
            println(3)
        """)
        assert(out == "1\n2\n99\n3\n") { out }
    }
    @Test
    fun gg_evt_hld4() {
        val out = ceu.all(
            """
            var fff
            set fff = func (x) { x }
            spawn task () {
                println(1)
                do {
                    println(2)
                    yield(nil)
                    println(3)
                }
                println(4)
                fff(evt[:type])
                println(99)
            }()
            broadcast @[(:type,:y)]
            broadcast @[(:type,:x)]
        """
        )
        //assert(out == "anon : (lin 8, col 21) : set error : incompatible scopes\n") { out }
        assert(out == "1\n2\n3\n4\n99\n") { out }
    }
    @Test
    fun gg_evt45() {
        val out = ceu.all(
            """
            spawn task () {
                println(111)
                yield(nil)
                println(222)
            }()
            println(1)
            broadcast nil
            println(2)
        """
        )
        assert(out == "111\n1\n222\n2\n") { out }
    }
    @Test
    fun gg_evt5() {
        val out = ceu.all(
            """
            spawn task () {
                loop {
                    println(evt)
                    yield(nil)
                }
            }()
            broadcast @[]
        """
        )
        assert(out == "nil\n@[]\n") { out }
    }
    @Test
    fun gg_evt6() {
        val out = ceu.all(
            """
            spawn task () {
                loop {
                    do {
                        yield(nil)
                    }
                    println(evt)
                }
            }()
            broadcast @[]
        """
        )
        assert(out == "@[]\n") { out }
    }
    @Test
    fun gg_evt7_err() {
        val out = ceu.all(
            """
            var x
            set x = []
            broadcast x
            println(x)
        """
        )
        //assert(out == "anon : (lin 4, col 13) : set error : incompatible scopes\n") { out }
        assert(out == "[]\n") { out }
        //assert(out == "anon : (lin 4, col 35) : broadcast error : incompatible scopes\n" +
        //        ":error\n") { out }
    }
    @Test
    fun gg_evt_hld8_err() {
        val out = ceu.all(
            """
            var tk
            set tk = task (xxx) {
                yield(nil)
                do {
                    val xxx' = evt[0]
                    nil
                }
            }
            var co = spawn (tk) ()
            broadcast #[[]]
            println(`:number CEU_GC.free`)
        """
        )
        assert(out == "2\n") { out }
        //assert(out == "anon : (lin 8, col 13) : broadcast [[]]\n" +
        //        "anon : (lin 4, col 31) : invalid index : cannot expose dynamic alien field\n") { out }
        //assert(out == "anon : (lin 9, col 13) : broadcast #[[]]\n" +
        //        "anon : (lin 5, col 17) : declaration error : incompatible scopes\n" +
        //        ":error\n") { out }
    }
    @Test
    fun gg_evt_hld9_err() {
        val out = ceu.all(
            """
            var tk
            set tk = task (xxx) {
                yield(nil)
                val xxx' = evt[0]
            }
            var co = spawn (tk) ()
            broadcast @[(1,[])]
            println(`:number CEU_GC.free`)
        """
        )
        assert(out == "2\n") { out }
        //assert(out == "anon : (lin 8, col 13) : broadcast [[]]\n" +
        //        "anon : (lin 4, col 31) : invalid index : cannot expose dynamic alien field\n") { out }
    }

    // PUB

    @Test
    fun hh_pub1_err() {
        val out = all("""
            var a
            a.pub
        """, true)
        assert(out == "anon : (lin 3, col 15) : pub error : expected task\n:error\n") { out }
    }
    @Test
    fun hh_pub2_err() {
        val out = all("""
            task.pub
        """, true)
        //assert(out == "anon : (lin 2, col 18) : pub error : expected enclosing task") { out }
        assert(out == "anon : (lin 2, col 13) : task error : missing enclosing task") { out }
    }
    @Test
    fun hh_pub3() {
        val out = all("""
            var t
            set t = task (v1) {
                set task.pub = v1
                yield(nil)
                set task.pub = task.pub + evt
                task.pub
            }
            var a = spawn (t) (1)
            println(a.pub)
            broadcast in a, 2
            println(a.pub)
        """, true)
        assert(out == "1\n3\n") { out }
    }
    @Test
    fun hh_pub4_err() {
        val out = all("""
            val t = task () {
                set task.pub = []
            }
            var a = spawn (t) ()
        """)
        //assert(out == "anon : (lin 11, col 25) : set error : incompatible scopes\n") { out }
        //assert(out == "anon : (lin 11, col 21) : set error : incompatible scopes\n") { out }
        //assert(out == "anon : (lin 11, col 27) : invalid pub : cannot expose dynamic \"pub\" field\n") { out }
        assert(out == "anon : (lin 5, col 28) : t()\n" +
                "anon : (lin 2, col 29) : block escape error : incompatible scopes\n:error\n") { out }
    }
    @Test
    fun hh_pub4a_err() {
        val out = all("""
            val T = task () {
                set task.pub = []
                yield(nil)
            }
            var x
            do {
                var a = spawn (T) ()
                set x = a.pub
                nil
            }
            println(x)
        """)
        assert(out == "anon : (lin 9, col 21) : set error : incompatible scopes\n" +
                ":error\n") { out }
        //assert(out == "anon : (lin 11, col 27) : invalid pub : cannot expose dynamic \"pub\" field\n") { out }
        //assert(out == "anon : (lin 8, col 32) : t()\n" +
        //        "anon : (lin 3, col 29) : set error : incompatible scopes\n:error\n") { out }
    }
    @Test
    fun hh_pub5() {
        val out = all("""
            var t
            set t = task () {
                set task.pub = 10
            }
            var a = spawn t()
            println(a.pub + a.pub)
        """, true)
        assert(out == "20\n") { out }
    }
    @Test
    fun hh_pub56_pool() {
        val out = all("""
            var T
            set T = task () {
                set task.pub = [10]  ;; valgrind test
            }
            spawn T()
            println(1)
        """)
        assert(out == "anon : (lin 6, col 19) : T()\n" +
                "anon : (lin 3, col 29) : block escape error : incompatible scopes\n:error\n") { out }
    }
    @Test
    fun hh_pub562_pool() {
        val out = all("""
            var T
            set T = task () {
                pass task.pub ;; useless test
                nil
            }
            spawn T()
            println(1)
        """)
        assert(out == "1\n") { out }
    }
    @Test
    fun hh_pub6_pool() {
        val out = all("""
            var T
            set T = task () {
                set task.pub = [10]
                yield(nil)
            }
            var ts
            set ts = tasks()
            spawn in ts, T()
            var x
            loop in :tasks ts, t {
                println(detrack(t).pub[0])
            }
        """)
        assert(out == "10\n") { out }
    }
    @Test
    fun hh_pub7_pool_err() {
        val out = all("""
            var T
            set T = task () {
                set task.pub = [10]
                yield(nil)
            }
            var ts
            set ts = tasks()
            spawn in ts, T()
            var x
            loop in :tasks ts, t {
                set x = detrack(t).pub   ;; TODO: incompatible scope
            }
            println(999)
        """)
        //assert(out == "20\n") { out }
        //assert(out == "anon : (lin 12, col 36) : invalid pub : cannot expose dynamic \"pub\" field\n:error\n") { out }
        assert(out == "anon : (lin 12, col 21) : set error : incompatible scopes\n:error\n") { out }
    }
    @Test
    fun hh_pub8_fake_task() {
        val out = all("""
            spawn (task () {
                set task.pub = 1
                spawn (task () :fake {
                    println(task.pub)
                }) ()
                nil
            }) ()
        """, true)
        assert(out == "1\n") { out }
    }
    @Test
    fun hh_pub9_fake_task_err() {
        val out = all("""
            spawn (task () {
                set task.pub = []
                var x
                spawn (task () :fake {
                    set x = task.pub
                }) ()
                println(x)
            }) ()
        """)
        assert(out == "[]\n") { out }
        //assert(out == "anon : (lin 2, col 20) : task () { set task.pub = [] var x spa...)\n" +
        //        "anon : (lin 5, col 24) : task () :fake { set x = task.pub }()\n" +
        //        "anon : (lin 6, col 34) : invalid pub : cannot expose dynamic \"pub\" field\n:error\n") { out }
        //assert(out == "anon : (lin 2, col 20) : task () { set task.pub = [] var x spawn task ...)\n" +
        //        "anon : (lin 5, col 24) : task () :fake { set x = task.pub }()\n" +
        //        "anon : (lin 6, col 25) : set error : incompatible scopes\n" +
        //        ":error\n") { out }
    }
    @Test
    fun hh_pub9_10_fake_task() {
        val out = all("""
            spawn (task () {
                set task.pub = [10]
                var x
                spawn (task () :fake {
                    set x = task.pub[0]
                }) ()
                println(x)
            }) ()
        """, true)
        assert(out == "10\n") { out }
    }
    @Test
    fun hh_pub10_fake_err() {
        val out = all("""
            spawn (task () :fake {
                task.pub
            }) ()
        """, true)
        //assert(out == "anon : (lin 3, col 22) : pub error : expected enclosing task") { out }
        assert(out == "anon : (lin 3, col 17) : task error : missing enclosing task") { out }
    }
    @Test
    fun hh_pub11_err() {
        val out = all("""
            var T
            set T = task () {
                set task.pub = [10]
                yield(nil)
            }
            var y
            do {
                var t = spawn (T) ()
                var x
                set x = t.pub  ;; pub expose
                set y = t.pub  ;; incompatible scopes
            }
            println(999)
        """)
        assert(out == "anon : (lin 11, col 21) : set error : incompatible scopes\n:error\n") { out }
        //assert(out == "anon : (lin 13, col 27) : invalid pub : cannot expose dynamic \"pub\" field\n:error\n") { out }
    }
    @Test
    fun hh_pub12_index_err() {
        val out = all("""
            var T
            set T = task () {
                set task.pub = [10]
                yield(nil)
            }
            var t = spawn(T)()
            var x
            set x = t.pub   ;; no expose
        """)
        assert(out == "anon : (lin 9, col 17) : set error : incompatible scopes\n:error\n") { out }
        //assert(out == "anon : (lin 11, col 23) : invalid pub : cannot expose dynamic \"pub\" field\n:error\n") { out }
    }
    @Test
    fun hh_pub13_index_err() {
        val out = all("""
            var T
            set T = task () {
                set task.pub = [10]
                yield(nil)
            }
            var t = spawn(T)()
            println(t.pub)   ;; no expose
        """)
        //assert(out == "anon : (lin 10, col 23) : invalid pub : cannot expose dynamic \"pub\" field\n") { out }
        assert(out == "[10]\n") { out }
    }
    @Test
    fun pub14_index_err() {
        val out = all("""
            var T
            set T = task () {
                set task.pub = [[@[(:x,10)]]]
                yield(nil)
            }
            var t = spawn T ()
            println(t.pub[0][0][:x])   ;; no expose
        """)
        assert(out == "10\n") { out }
        //assert(out == "anon : (lin 10, col 27) : invalid index : cannot expose dynamic \"pub\" field\n:error\n") { out }
    }
    @Test
    fun hh_pub15_task() {
        val out = all("""
        spawn task () :fake { 
            var y
            set y = do {     
                var ceu_spw_54     
                set ceu_spw_54 = spawn task () :fake {         
                    yield(nil)         
                    [2]             
                }()        
                yield(nil)     
                ;;println(ceu_spw_54.pub)     
                ceu_spw_54.pub        
            }     
            println(y) 
        }()
        broadcast nil
        """)
        assert(out == "[2]\n") { out }
        //assert(out == "anon : (lin 16, col 9) : broadcast nil\n" +
        //        "anon : (lin 12, col 28) : invalid pub : cannot expose dynamic \"pub\" field\n:error\n") { out }
    }
    @Test
    fun hh_pub15a_task_err() {
        val out = all("""
        spawn task () :fake { 
            var y
            set y = do {     
                var ceu_spw_54     
                set ceu_spw_54 = spawn task () {         
                    set task.pub = [2]             
                    yield(nil)         
                }()        
                ;;yield(nil)     
                ;;println(ceu_spw_54.pub)     
                ceu_spw_54.pub        
            }     
            println(y) 
        }()
        broadcast nil
        """)
        assert(out == "anon : (lin 2, col 15) : (task () :fake { var y set y = do { var ceu_s...)\n" +
                "anon : (lin 4, col 21) : block escape error : incompatible scopes\n" +
                ":error\n") { out }
        //assert(out == "anon : (lin 16, col 9) : broadcast nil\n" +
        //        "anon : (lin 12, col 28) : invalid pub : cannot expose dynamic \"pub\" field\n:error\n") { out }
    }
    @Test
    fun todo_hh_pub16_err() {
        val out = all("""
            var t
            set t = task (v) {
                set task.pub = v
                yield(nil)
                var x
                set x = [2]
                set task.pub = x
                yield(nil)
                set task.pub = @[(:y,copy(evt))]
                move(task.pub)
            }
            var a = spawn (t) ([1])
            ;;println(a.pub)
            broadcast in a, nil
            ;;println(a.pub)
            broadcast in a, [3]
            ;;println(a.pub)
        """, true)
        //assert(out == "[1]\n[2]\n@[(:y,[3])]\n") { out }
        assert(out == "TODO\n") { out }
    }
    @Test
    fun hh_17_pub_out() {
        val out = all("""
            var t = task () {
                set task.pub = []
                yield(nil)
                nil
            }
            var a = spawn (t) ()
            println(a.pub)
            a.pub
        """)
        assert(out == "[]\n") { out }
    }
    @Test
    fun hh_18_pub_out_err() {
        val out = all("""
            var t = task () {
                set task.pub = []
                task.pub
            }
            var a = spawn (t) ()
            println(a.pub)
        """)
        //assert(out == "[]\n") { out }
        assert(out == "anon : (lin 6, col 28) : t()\n" +
                "anon : (lin 2, col 29) : block escape error : incompatible scopes\n" +
                ":error\n") { out }
    }
    @Test
    fun hh_19_pub_tasks_tup() {
        val out = all("""
            val tup = []
            val T = task () {
                set task.pub = tup
                yield(nil)
            }
            val ts = tasks()
            spawn in ts, T()
            spawn in ts, T()
            println(:ok)
        """)
        assert(out == ":ok\n") { out }
    }
    @Test
    fun hh_20_pub_pass() {
        val out = all("""
            val S = task (t) {
                println(t)
                yield(nil)
            }
            val T = task () {
                set task.pub = [1,2,3]
                spawn S(task.pub)
                nil
            }
            spawn T()
        """)
        assert(out == "[1,2,3]\n") { out }
    }

    // STATUS

    @Test
    fun gg_0X_status_coro() {
        val out = test("""
            var t
            set t = coro () {
                println(10, status(coro))
                yield(nil)
                println(20, status(coro))
            }
            var a
            set a = coroutine(t)
            println(1, status(a))
            resume a()
            println(2, status(a))
            resume a()
            println(3, status(a))
        """)
        assert(out == "1\t:yielded\n10\t:resumed\n2\t:yielded\n20\t:resumed\n3\t:terminated\n") { out }
    }

    @Test
    fun ii_status2_err() {
        val out = all("""
            status(task)
        """, true)
        //assert(out == "anon : (lin 2, col 18) : status error : expected enclosing task") { out }
        assert(out == "anon : (lin 2, col 20) : task error : missing enclosing task") { out }
    }
    @Test
    fun ii_status3_err() {
        val out = all("""
            var t
            set t = task () {
                set status(task) = nil     ;; error: cannot assign to status
            }
        """, true)
        assert(out == "anon : (lin 4, col 17) : set error : expected assignable destination") { out }
    }
    @Test
    fun todo_ii_status5() {
        val out = all("""
            var T
            set T = task (x) {
                println(10, status(task))
                yield(nil)
                if x {
                    yield(nil)
                } else {
                    nil
                }
                println(20, status(task))
            }
            spawn task () {
                do {
                    var t1
                    set t1 = coroutine(T)
                    resume t1(false)
                    var t2
                    set t2 = coroutine(T)
                    resume t2(true)
                    ${await("evt == t1")}
                    println(:ok)
                }
            } ()
            broadcast nil
        """)
        //assert(out == "anon : (lin 11, col 25) : set error : incompatible scopes\n") { out }
        //assert(out == "anon : (lin 11, col 21) : set error : incompatible scopes\n") { out }
        assert(out == "1\t:yielded\n10\t:resumed\n2\t:yielded\n20\t:resumed\n3\t:terminated\n") { out }
    }

    // TOGGLE

    @Test
    fun jj_01_toggle_tasks() {
        val out = test("""
            val T = task () {
                yield(nil) { as it => nil }
                println(10)
            }
            val ts = tasks()
            spawn T() in ts
            toggle ts (false)
            println(1)
            broadcast( nil)
            toggle ts (true)
            println(2)
            broadcast (nil)
        """)
        assert(out == "1\n2\n10\n") { out }
    }
    @Test
    fun jj_toggle6_defer_tasks() {
        val out = all("""
            var T
            set T = task () {
                defer {
                    println(10)
                }
                yield(nil)
                println(999)
            }
            var ts
            set ts = tasks()
            spawn in ts, T()
            toggle ts (false)
            println(1)
            broadcast nil
            println(2)
        """)
        assert(out == "1\n2\n10\n") { out }
    }

    // TRACK / DETRACK

    @Test
    fun oo_06_track() {
        val out = test("""
            var T = task (v) {
                set pub = [v]
                yield(nil) { as it => nil }
            }
            var x
            var ts = tasks()
            spawn in ts, T(1)
            spawn in ts, T(2)
            loop in :tasks ts, t {
                set x = copy(t)
            }
            println(detrack(x).pub[0])   ;; 2
            broadcast nil
            println(detrack(x))   ;; nil
        """)
        assert(out == "2\nnil\n") { out }
    }
    @Test
    fun ll_track10() {
        val out = all("""
            var T
            set T = task (v) {
                set task.pub = [v]
                yield(nil)
            }
            var x
            var ts
            set ts = tasks()
            do {
                spawn in ts, T(1)
                spawn in ts, T(2)
                loop in :tasks ts, t {
                    set x = copy(t)    ;; track(t) up_hold in
                }
                println(detrack(x).pub[0])   ;; 2
                broadcast nil
                println(detrack(x))   ;; nil
            }
        """)
        assert(out == "2\nnil\n") { out }
        //assert(out == "anon : (lin 14, col 25) : set error : incompatible scopes\n") { out }
    }
    @Test
    fun ll_track12_throw() {
        val out = all("""
            var T
            set T = task (v) {
                yield(nil)
            }
            var ts
            set ts = tasks()
            spawn in ts, T(1)
            var x
            set x = catch true {
                loop in :tasks ts, t {
                    throw(copy(t))
                }
            }
            broadcast nil
            println(detrack(x))   ;; nil
        """)
        assert(out == "nil\n") { out }
    }
    @Test
    fun ll_track13_throw() {
        val out = all("""
            var T
            set T = task (v) {
                set task.pub = [v]
                yield(nil)
            }
            var ts
            set ts = tasks()
            spawn in ts, T(1)
            spawn in ts, T(2)
            var x
            set x = catch true {
                loop in :tasks ts, t {
                    throw(copy(t))
                }
            }
            println(detrack(x).pub[0])   ;; 1
            println(status(detrack(x)))   ;; :yielded
            broadcast nil
            println(detrack(x))   ;; nil
        """)
        assert(out == "1\n:yielded\nnil\n") { out }
    }
    @Test
    fun ll_track15_simplify() {
        val out = all("""
            var T = task (v) {
                yield(nil)
            }
            var ts = tasks()
            spawn in ts, T(1)
            spawn in ts, T(2)
            var x
            loop in :tasks ts, t {
                set x = copy(t)
            }
            broadcast nil
            println(detrack(x))   ;; nil
        """)
        assert(out == "nil\n") { out }
    }

    // EVT / DATA

    @Test
    fun todo_mm_07_data_pub() {
        val out = all("""
            data :T = [x,y]
            var t :T = spawn task () {
                set task.pub = [10,20]
                nil
            } ()
            data :X = [a:T]
            var x :X = [t]
            println(x.a.pub.y)  // TODO: combine Pub/Index
        """, true)
        assert(out == "20\n") { out }
    }
    @Test
    fun todo_mm_08_data_pool_pub() {
        val out = all("""
            data :T = [x,y]
            var ts = tasks()
            spawn in ts, task () {
                set task.pub = [10,20]
                yield(nil)
            } ()
            loop in :tasks ts, t:T {
                println(detrack(t).pub.y)   // TODO: detrack needs to return to grammar
            }
        """, true)
        assert(out == "20\n") { out }
    }

    // EXPOSE

    @Test
    fun kj_07_pub_err_expose() {
        val out = test("""
            var t
            set t = task () {
                set pub = []
            }
            var a = spawn (t) ()
            var x
            set x = pub(a)  ;; seria bom que o pub guardasse o retorno,
                            ;; uma vez que ele já se "desfez" (gc_dec) do pub
                            ;; poderia ser uma union pub/ret
            println(x)
        """)
        //assert(out == "anon : (lin 10, col 23) : invalid pub : cannot expose dynamic \"pub\" field\n") { out }
        assert(out == "anon : (lin 6, col 28) : t()\n" +
                "anon : (lin 3, col 29) : block escape error : incompatible scopes\n:error\n") { out }
    }
    @Test
    fun nn_pub18_err_expose() {
        val out = all("""
            var t
            set t = task () {
                set task.pub = @[]
            }
            var a = spawn (t) ()
            var x
            set x = a.pub
            println(x)
        """)
        //assert(out == "anon : (lin 10, col 23) : invalid pub : cannot expose dynamic \"pub\" field\n") { out }
        assert(out == "anon : (lin 6, col 28) : t()\n" +
                "anon : (lin 3, col 29) : block escape error : incompatible scopes\n:error\n") { out }
    }
    @Test
    fun nn_pub19_err_expose() {
        val out = all("""
            var t
            set t = task () {
                set task.pub = #[]
            }
            var a = spawn (t) ()
            var x
            set x = a.pub
            println(x)
        """)
        assert(out == "anon : (lin 6, col 28) : t()\n" +
                "anon : (lin 3, col 29) : block escape error : incompatible scopes\n:error\n") { out }
    }
    @Test
    fun kj_09_pub_nopub() {
        val out = test("""
            var U
            set U = task () {
                set pub = func () {
                    10
                }
            }
            var T
            set T = task (u) {
                println(pub(u))
            }
            spawn T (spawn U())
            println(:ok)
        """)
        assert(out == "anon : (lin 12, col 28) : U()\n" +
                "anon : (lin 3, col 29) : block escape error : incompatible scopes\n:error\n") { out }
    }
    @Test
    fun nn_pub_23_nopub() {
        val out = all("""
            var U
            set U = task () {
                set task.pub = [10]
            }
            var T
            set T = task (u) {
                nil ;;println(u.pub.0)
            }
            spawn T (spawn U())
            println(:ok)
        """)
        assert(out == "anon : (lin 10, col 28) : U()\n" +
                "anon : (lin 3, col 29) : block escape error : incompatible scopes\n:error\n") { out }
    }
    @Test
    fun nn_pub_24_nopub() {
        val out = all("""
            var U
            set U = task () {
                var x
                set x = [10]
            }
            var T
            set T = task (u) {
                nil ;;println(u.pub.0)
            }
            spawn T (spawn U())
        """)
        assert(out == "anon : (lin 11, col 28) : U()\n" +
                "anon : (lin 3, col 29) : block escape error : incompatible scopes\n:error\n") { out }
    }


    @Test
    fun nn_pub26_pool_err() {
        val out = all("""
            var T = task () {
                set task.pub = [10]
                yield(nil)
            }
            var ts = tasks()
            spawn in ts, T()
            loop in :tasks ts, t {
                var x = detrack(t).pub
                broadcast in detrack(t), nil
                println(x)
            }
            println(999)
        """)
        //assert(out == "20\n") { out }
        //assert(out == "anon : (lin 12, col 36) : invalid pub : cannot expose dynamic \"pub\" field\n:error\n") { out }
        assert(out == "anon : (lin 9, col 17) : declaration error : incompatible scopes\n:error\n") { out }
    }
    @Test
    fun nn_pub27_func_expose() {
        val out = all("""
            var t = task (v) {
                set task.pub = v
                var f = func (p) {
                    p
                }
                println(f(task.pub))
            }
            var a = spawn (t) ([1])
        """, true)
        assert(out == "[1]\n") { out }
        //assert(out == "anon : (lin 13, col 20) : a([1])\n" +
        //        "anon : (lin 9, col 25) : f()\n" +
        //        "anon : (lin 7, col 26) : invalid pub : cannot expose dynamic \"pub\" field\n:error\n") { out }
    }
    @Test
    fun nn_pub28_func_tst() {
        val out = all("""
            var t = task (v) {
                set task.pub = v
                var xxx
                nil
            }
            var a = spawn (t) ([])
            println(:ok)
        """)
        assert(out == ":ok\n") { out }
    }
    @Test
    fun nn_pub30_pool_err() {
        val out = all("""
            var T = task () {
                set task.pub = [10]
                yield(nil)
            }
            var ts = tasks()
            spawn in ts, T()
            loop in :tasks ts, t {
                var f = func (tt) {
                    var x = detrack(tt).pub
                    broadcast in detrack(tt), nil
                    println(x)
                }
                f(t)
            }
            println(999)
        """)
        //assert(out == "20\n") { out }
        //assert(out == "anon : (lin 12, col 36) : invalid pub : cannot expose dynamic \"pub\" field\n:error\n") { out }
        assert(out == "anon : (lin 14, col 17) : f(t)\n" +
                "anon : (lin 10, col 21) : declaration error : incompatible scopes\n" +
                ":error\n") { out }
    }
    @Test
    fun nn_pub31_func_expose() {
        val out = all("""
            var f = func (t) {
                t.pub
            }
            var T = task () {
                set task.pub = []
                yield(nil)
            }
            var t = spawn (T) ()
            println(f(t))
        """)
        //assert(out == "[]\n") { out }
        //assert(out == "anon : (lin 13, col 20) : a([1])\n" +
        //        "anon : (lin 9, col 25) : f()\n" +
        //        "anon : (lin 7, col 26) : invalid pub : cannot expose dynamic \"pub\" field\n:error\n") { out }
        assert(out == "anon : (lin 10, col 21) : f(t)\n" +
                "anon : (lin 2, col 30) : block escape error : incompatible scopes\n" +
                ":error\n") { out }
    }

    // XCEU

    @Test
    fun zz_xceu1() {
        val out = all("""
            spawn task () {
                spawn (task () {
                    yield(nil)
                }) ()
                yield(nil)
                throw(nil)
            }()
            println(1)
        """)
        assert(out == "1\n") { out }
        //assert(out == "anon : (lin 14, col 25) : set error : incompatible scopes\n") { out }
    }
    @Test
    fun zz_xceu2() {
        val out = all("""
            spawn task () {
                yield(nil)
                println(evt)
                spawn (task () {
                    loop {
                        println(evt)    ;; lost reference
                        yield(nil)
                    }
                }) ()
                yield(nil)
            }()
            broadcast 10
            broadcast 20
        """)
        assert(out == "10\nnil\n20\n") { out }
        //assert(out == "anon : (lin 14, col 25) : set error : incompatible scopes\n") { out }
    }
    @Test
    fun zz_xceu3() {
        val out = all("""
            spawn task () {
                yield(nil)
                println(evt)
                spawn (task () :fake {
                    loop {
                        println(evt)    ;; kept reference
                        yield(nil)
                    }
                }) ()
                yield(nil)
            }()
            broadcast 10
            broadcast 20
        """)
        assert(out == "10\n10\n20\n") { out }
        //assert(out == "anon : (lin 14, col 25) : set error : incompatible scopes\n") { out }
    }
    @Test
    fun zz_xceu4() {
        val out = all("""
            catch true {
                spawn task () :fake {
                    throw([tags([],:x,true)])
                }()
            }
            println(1)
        """)
        assert(out == "1\n") { out }
        //assert(out == "anon : (lin 14, col 25) : set error : incompatible scopes\n") { out }
    }
    @Test
    fun zz_xceu5() {
        val out = all("""
            spawn task () {
                catch err==:or {
                    spawn task () {
                        yield(nil)
                        ;;println(:evt, evt)
                        ;;println(111)
                        throw(:or)
                    }()
                    spawn task () {
                        yield(nil)
                        ;;println(:evt, evt)
                        ;;println(222)
                        throw(:or)
                    }()
                    yield(nil)
                    ;;println(:in)
                }
                ;;println(:out)
            }()
            broadcast nil
            println(1)
        """)
        assert(out == "1\n") { out }
        //assert(out == "anon : (lin 14, col 25) : set error : incompatible scopes\n") { out }
    }
    @Test
    fun zz_xceu6() {
        val out = all("""
            var T
            set T = task (pos) {
                yield(nil)
                println(pos)
            }
            spawn (task () {
                var ts
                set ts = tasks()
                do {
                    spawn in ts, T([])  ;; pass [] to ts
                }
                yield(nil)
                yield(nil)
            })()
            broadcast nil
        """)
        assert(out == "[]\n") { out }
    }
    @Test
    fun zz_xceu7() {
        val out = all("""
            spawn task () {
                do {
                    spawn task () {
                        yield(nil)
                    } ()
                    yield(nil)
                }
                broadcast [[]]
                ;;await true
            }()
            broadcast nil
            println(:ok)
        """)
        assert(out == ":ok\n") { out }
    }
    @Test
    fun zz_xceu8() {
        val out = all("""
            spawn task () {
                do {
                    spawn task () {
                        yield(nil)
                    } ()
                    yield(nil)
                }
                broadcast tags([], :x, true)
            }()
            broadcast nil
            println(:ok)
        """)
        assert(out == ":ok\n") { out }
    }
    @Test
    fun zz_xceu9 () {
        val out = all("""
            spawn task () {
                do {
                    spawn task () {
                        yield(nil)
                    }()
                    yield(nil)
                    nil
                }
                do {
                    nil
                }
            } ()
            broadcast nil
            println(:ok)
        """)
        assert(out == ":ok\n") { out }
    }
    @Test
    fun zz_xceu10 () {
        val out = all("""
            ;;println(:blk0, `:pointer ceu_block`)
            spawn task () {
                ;;println(:cor1, `:pointer ceu_x`)
                ;;println(:blk11, `:pointer ceu_block`)
                loop {
                    ;;println(:blk12, `:pointer ceu_block`)
                    yield(nil); loop until evt==10 { yield(nil) }
                    println(:1)
                    var t = spawn task () {
                        ;;println(:cor2, `:pointer ceu_x`)
                        ;;println(:blk2, `:pointer ceu_block`)
                        yield(nil); loop until evt==10 { yield(nil) }
                    } ()
                    loop until status(t)==:terminated { yield(nil) }
                    println(:2)
                }
            } ()
            ;;println(:xxxxxxxxxxxxxxxxxxxxxxx)
            broadcast 10    ;; :1
            ;;println(:xxxxxxxxxxxxxxxxxxxxxxx)
            broadcast 10    ;; :2 (not :1 again)
        """, true)
        assert(out == ":1\n:2\n") { out }
    }
    @Test
    fun zz_xceu11 () {
        val out = all("""
            data :X = [x]
            task () :X {
                task () :fake {
                    task.pub.x
                }
            }
            println(:ok)
        """)
        assert(out == ":ok\n") { out }
    }
    @Test
    fun zz_12_kill() {
        val out = all("""
            spawn task () {
                do {
                    val t1 = spawn task () {
                        ${yield()}
                        println(1)
                    } ()
                    spawn task () {
                        defer { println(3) }
                        ${yield()}
                        println(2)
                    } ()
                    ${await ("t1")}
                }
                println(999)
            } ()
            broadcast nil
        """, true)
        assert(out == "1\n3\n999\n") { out }
    }
    @Test
    fun all_01() {
        val out = test("""
            val T = (task () {
                set task.pub = []
                yield(nil)
            })
            val f = (func (v) {
                nil
            })
            do {
                val xxx = spawn T()
                do {
                    val zzz = xxx
                    nil
                }
                f(xxx.pub)
            }
            println(:ok)
        """)
        assert(out == ":ok\n") { out }
    }

}
