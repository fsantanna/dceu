class TParser {

    // EXPR.VAR / EVT / ERR

    @Test
    fun evt3 () {
        val l = lexer(" evt ")
        val parser = Parser(l)
        val e = parser.exprPrim()
        assert(e is Expr.EvtErr && e.tk.str == "evt")
    }
    @Test
    fun err4 () {
        val l = lexer(" err ")
        val parser = Parser(l)
        val e = parser.exprPrim()
        assert(e is Expr.EvtErr && e.tk.str == "err")
    }

    // EXPR.INDEX / PUB

    @Test
    fun pub3() {
        val l = lexer("x . pub")
        val parser = Parser(l)
        val e = parser.expr()
        assert(e is Expr.Pub && e.x is Expr.Acc)
        assert(e.tostr() == "x.pub") { e.tostr() }
    }
    @Test
    fun index5_err() {
        val l = lexer("x . .")
        val parser = Parser(l)
        assert(trap { parser.exprSufs() } == "anon : (lin 1, col 5) : expected \"pub\" : have \".\"")
    }
    @Test
    fun index6_err() {
        val l = lexer("x . 2")
        val parser = Parser(l)
        assert(trap { parser.exprSufs() } == "anon : (lin 1, col 5) : expected \"pub\" : have \"2\"")
    }
    @Test
    fun pub7_err() {
        val l = lexer("set pub = x.pub + pub")
        val parser = Parser(l)
        assert(trap { parser.exprSufs() } == "anon : (lin 1, col 5) : expected expression : have \"pub\"")
    }
    @Test
    fun pub8() {
        val l = lexer("set task.pub = x.pub + task.pub")
        val parser = Parser(l)
        val e = parser.expr()
        assert(e.tostr() == "set task.pub = {{+}}(x.pub,task.pub)") { e.tostr() }
    }

    // EXPR.SET

    @Test
    fun set_evt_err() {
        val l = lexer("set evt = nil")
        val parser = Parser(l)
        assert(trap { parser.expr() } == "anon : (lin 1, col 1) : invalid set : expected assignable destination")
    }
    @Test
    fun set_err_err() {
        val l = lexer("set err = nil")
        val parser = Parser(l)
        assert(trap { parser.expr() } == "anon : (lin 1, col 1) : invalid set : expected assignable destination")
    }

    // EXPORT

    @Test
    fun expr_export1_err() {
        val l = lexer("export {}")
        val parser = Parser(l)
        assert(trap { parser.exprPrim() } == "anon : (lin 1, col 8) : expected \"[\" : have \"{\"")
    }
    @Test
    fun expr_export2_err() {
        val l = lexer("export [:x] {}")
        val parser = Parser(l)
        assert(trap { parser.exprPrim() } == "anon : (lin 1, col 9) : expected identifier : have \":x\"")
    }
    @Test
    fun expr_export3() {
        val l = lexer("export [] { nil }")
        val parser = Parser(l)
        val e = parser.exprPrim()
        assert(e is Expr.Export && e.ids.isEmpty() && e.body.es.size==1)
        assert(e.tostr() == "export [] {\nnil\n}") { e.tostr() }
    }
    @Test
    fun expr_export4() {
        val l = lexer("export [x] { nil }")
        val parser = Parser(l)
        val e = parser.exprPrim()
        assert(e is Expr.Export && e.ids.first()=="x" && e.body.es.size==1)
        assert(e.tostr() == "export [x] {\nnil\n}") { e.tostr() }
    }
    @Test
    fun expr_export5() {
        val l = lexer("export [x,y] { nil }")
        val parser = Parser(l)
        val e = parser.exprPrim()
        assert(e is Expr.Export && e.ids.last()=="y" && e.body.es.size==1 && e.ids.size==2)
        assert(e.tostr() == "export [x,y] {\nnil\n}") { e.tostr() }
    }

    // GROUP
/*
    @Test
    fun group1_err() {
        val l = lexer("do :x {}")
        val parser = Parser(l)
        //assert(trap { parser.exprPrim() } == "anon : (lin 1, col 1) : invalid group : unexpected \":x\"")
        assert(trap { parser.exprPrim() } == "anon : (lin 1, col 4) : expected \"{\" : have \":x\"")
    }
    @Test
    fun group2() {
        val l = lexer("do :unnest { pass 1 ; 2 }")
        val parser = Parser(l)
        val e = parser.exprPrim()
        assert(e is Expr.Do && e.es.size==2)
        assert(e.tostr() == "do :unnest {\npass 1\n2\n}") { e.tostr() }
    }
    @Test
    fun group3() {
        val l = lexer("do :unnest-hide { pass x; pass y; z; }")
        val parser = Parser(l)
        val e = parser.exprPrim()
        assert(e is Expr.Do && e.es.size==3)
        assert(e.tostr() == "do :unnest-hide {\npass x\npass y\nz\n}") { e.tostr() }
    }
*/

    // TASK / YIELD / RESUME

    @Test
    fun func3_err() {
        val l = lexer("""
            func () :fake {}
        """.trimIndent())
        val parser = Parser(l)
        assert(trap { parser.expr() } == "anon : (lin 1, col 9) : expected \"{\" : have \":fake\"")
    }
    @Test
    fun task4_err() {
        val l = lexer("""
            task :xxx () {}
        """.trimIndent())
        val parser = Parser(l)
        //assert(trap { parser.expr() } == "anon : (lin 1, col 1) : invalid task : unexpected \":xxx\"")
        assert(trap { parser.expr() } == "anon : (lin 1, col 6) : expected \"(\" : have \":xxx\"")
    }
    @Test
    fun coro_err() {
        val l = lexer("coro (a,b) :fake { 10 }")
        val parser = Parser(l)
        assert(trap { parser.expr_prim() } == "anon : (lin 1, col 12) : expected \"{\" : have \":fake\"")
    }

    // BROADCAST

    @Test
    fun bcast_coro1_err() {
        val l = lexer("broadcast in")
        val parser = Parser(l)
        assert(trap { parser.expr() } == "anon : (lin 1, col 13) : expected expression : have end of file")
    }
    @Test
    fun bcast_coro2_err() {
        val l = lexer("broadcast in x")
        val parser = Parser(l)
        assert(trap { parser.expr() } == "anon : (lin 1, col 15) : expected \",\" : have end of file")
    }
    @Test
    fun bcast_coro3_err() {
        val l = lexer("broadcast in x,")
        val parser = Parser(l)
        assert(trap { parser.expr() } == "anon : (lin 1, col 16) : expected expression : have end of file")
    }
    @Test
    fun bcast_coro4() {
        val l = lexer("broadcast in x, 10")
        val parser = Parser(l)
        val e = parser.exprs()
        assert(e.tostr() == "broadcast in x, 10\n") { e.tostr() }
    }

    // TOGGLE

    @Test
    fun toggle1() {
        val l = lexer("toggle t(true)")
        val parser = Parser(l)
        val e = parser.exprs()
        assert(e.tostr() == "toggle t(true)\n") { e.tostr() }
    }
    @Test
    fun toggle2_err() {
        val l = lexer("toggle x")
        val parser = Parser(l)
        assert(trap { parser.expr() } == "anon : (lin 1, col 8) : invalid toggle : expected argument")
    }
    @Test
    fun toggle3_err() {
        val l = lexer("toggle")
        val parser = Parser(l)
        assert(trap { parser.expr() } == "anon : (lin 1, col 7) : expected expression : have end of file")
    }
    @Test
    fun toggle4_err() {
        val l = lexer("toggle x(1,2)")
        val parser = Parser(l)
        assert(trap { parser.expr() } == "anon : (lin 1, col 8) : invalid toggle : expected single argument")
    }
    @Test
    fun toggle5_err() {
        val l = lexer("toggle f()")
        val parser = Parser(l)
        assert(trap { parser.expr() } == "anon : (lin 1, col 8) : invalid toggle : expected single argument")
    }

    // TASKS

    @Ignore // now expands to complex C code
    @Test
    fun tasks1() {
        val l = lexer("""
            var ts
            set ts = tasks()
            loop in :tasks ts, t {
                nil
            }
        """)
        val parser = Parser(l)
        val e = parser.exprs()
        assert(e.tostr() == "var ts\nset ts = tasks()\nlopp in :tasks ts, t {\nnil\n}\n") { e.tostr() }
    }
    @Test
    fun tasks2_err() {
        val l = lexer("""
            var ts
            set ts = tasks()
            loop in :tasks ts, 1 {
                nil
            }
        """)
        val parser = Parser(l)
        assert(trap { parser.exprs() } == "anon : (lin 4, col 32) : expected identifier : have \"1\"")
    }
    @Test
    fun tasks3_err() {
        val l = lexer("""
            var ts
            set ts = tasks()
            loop in :tasks x {
                nil
            }
        """)
        val parser = Parser(l)
        assert(trap { parser.exprs() } == "anon : (lin 4, col 30) : expected \",\" : have \"{\"")
    }
    @Test
    fun tasks4_err() {
        val l = lexer("""
            spawn in nil, {}
        """)
        val parser = Parser(l)
        assert(trap { parser.exprs() } == "anon : (lin 2, col 27) : expected expression : have \"{\"")
    }
    @Test
    fun tasks5_err() {
        val l = lexer("""
            spawn in ()
        """)
        val parser = Parser(l)
        assert(trap { parser.exprs() } == "anon : (lin 2, col 23) : expected expression : have \")\"")
    }
    @Test
    fun tasks6_err() {
        val l = lexer("""
            spawn in nil, f
        """)
        val parser = Parser(l)
        assert(trap { parser.exprs() } == "anon : (lin 3, col 9) : invalid spawn : expected call")
    }

    // ITER

    @Test
    fun iter1_err() {
        val l = lexer("""
            loop in 1 {
                nil
            }
        """)
        val parser = Parser(l)
        assert(trap { parser.exprs() } == "anon : (lin 2, col 21) : invalid loop : unexpected 1")
    }
    @Test
    fun iter2_err() {
        val l = lexer("""
            loop in :tasks {
                nil
            }
        """)
        val parser = Parser(l)
        assert(trap { parser.exprs() } == "anon : (lin 2, col 28) : expected expression : have \"{\"")
    }

    // TRACK

    @Test
    fun track1() {
        val l = lexer("""
            track(x)
        """)
        val parser = Parser(l)
        val e = parser.exprs()
        assert(e.tostr() == "track(x)\n") { e.tostr() }
    }

    // POLY
    /*
    @Test
    fun gg_01_poly_err() {
        val l = lexer("poly x")
        val parser = Parser(l)
        assert(trap { parser.expr() } == "anon : (lin 1, col 6) : poly error : expected var or set")
    }
    @Test
    fun gg_02_poly_err() {
        val l = lexer("poly var x = 1")
        val parser = Parser(l)
        assert(trap { parser.exprs() } == "anon : (lin 1, col 12) : expected expression : have \"=\"")
    }
    @Test
    fun gg_03_poly() {
        val l = lexer("poly var x")
        val parser = Parser(l)
        val e = parser.expr()
        assert(e.tostr(false) == "poly var x") { e.tostr() }
    }
    @Test
    fun gg_04_poly_err() {
        val l = lexer("poly set x = 1")
        val parser = Parser(l)
        assert(trap { parser.exprs() } == "anon : (lin 1, col 14) : expected \"func\" : have \"1\"")
    }
    @Test
    fun gg_05_poly_set_tag() {
        val l = lexer("poly set min :number = 1")
        val parser = Parser(l)
        val e = parser.expr()
        assert(e.tostr(false) == "set min[:number] = 1") { e.tostr() }
    }
    @Test
    fun gg_06_poly_set_func() {
        val l = lexer("poly set f = func () { nil }")
        val parser = Parser(l)
        val e = parser.expr()
        assert(e.tostr(false) == "poly var x") { e.tostr() }
    }
    @Test
    fun gg_07_poly_set_err() {
        val l = lexer("poly set f.x :number = 10")
        val parser = Parser(l)
        val e = parser.expr()
        assert(e.tostr(false) == "poly var x") { e.tostr() }
    }
    */
}
