class TParser {
    // EXPORT

    @Test
    fun expr_export1_err() {
        val l = lexer("export {}")
        val parser = Parser(l)
        assert(trap { parser.exprPrim() } == "anon : (lin 1, col 8) : expected \"[\" : have \"{\"")
    }
    @Test
    fun expr_export2_err() {
        val l = lexer("export [:x] {}")
        val parser = Parser(l)
        assert(trap { parser.exprPrim() } == "anon : (lin 1, col 9) : expected identifier : have \":x\"")
    }
    @Test
    fun expr_export3() {
        val l = lexer("export [] { nil }")
        val parser = Parser(l)
        val e = parser.exprPrim()
        assert(e is Expr.Export && e.ids.isEmpty() && e.body.es.size==1)
        assert(e.tostr() == "export [] {\nnil\n}") { e.tostr() }
    }
    @Test
    fun expr_export4() {
        val l = lexer("export [x] { nil }")
        val parser = Parser(l)
        val e = parser.exprPrim()
        assert(e is Expr.Export && e.ids.first()=="x" && e.body.es.size==1)
        assert(e.tostr() == "export [x] {\nnil\n}") { e.tostr() }
    }
    @Test
    fun expr_export5() {
        val l = lexer("export [x,y] { nil }")
        val parser = Parser(l)
        val e = parser.exprPrim()
        assert(e is Expr.Export && e.ids.last()=="y" && e.body.es.size==1 && e.ids.size==2)
        assert(e.tostr() == "export [x,y] {\nnil\n}") { e.tostr() }
    }

    // GROUP
/*
    @Test
    fun group1_err() {
        val l = lexer("do :x {}")
        val parser = Parser(l)
        //assert(trap { parser.exprPrim() } == "anon : (lin 1, col 1) : invalid group : unexpected \":x\"")
        assert(trap { parser.exprPrim() } == "anon : (lin 1, col 4) : expected \"{\" : have \":x\"")
    }
    @Test
    fun group2() {
        val l = lexer("do :unnest { pass 1 ; 2 }")
        val parser = Parser(l)
        val e = parser.exprPrim()
        assert(e is Expr.Do && e.es.size==2)
        assert(e.tostr() == "do :unnest {\npass 1\n2\n}") { e.tostr() }
    }
    @Test
    fun group3() {
        val l = lexer("do :unnest-hide { pass x; pass y; z; }")
        val parser = Parser(l)
        val e = parser.exprPrim()
        assert(e is Expr.Do && e.es.size==3)
        assert(e.tostr() == "do :unnest-hide {\npass x\npass y\nz\n}") { e.tostr() }
    }
*/

    // TOGGLE

    @Test
    fun toggle1() {
        val l = lexer("toggle t(true)")
        val parser = Parser(l)
        val e = parser.exprs()
        assert(e.tostr() == "toggle t(true)\n") { e.tostr() }
    }
    @Test
    fun toggle2_err() {
        val l = lexer("toggle x")
        val parser = Parser(l)
        assert(trap { parser.expr() } == "anon : (lin 1, col 8) : invalid toggle : expected argument")
    }
    @Test
    fun toggle3_err() {
        val l = lexer("toggle")
        val parser = Parser(l)
        assert(trap { parser.expr() } == "anon : (lin 1, col 7) : expected expression : have end of file")
    }
    @Test
    fun toggle4_err() {
        val l = lexer("toggle x(1,2)")
        val parser = Parser(l)
        assert(trap { parser.expr() } == "anon : (lin 1, col 8) : invalid toggle : expected single argument")
    }
    @Test
    fun toggle5_err() {
        val l = lexer("toggle f()")
        val parser = Parser(l)
        assert(trap { parser.expr() } == "anon : (lin 1, col 8) : invalid toggle : expected single argument")
    }

    // TASKS

    @Ignore // now expands to complex C code
    @Test
    fun tasks1() {
        val l = lexer("""
            var ts
            set ts = tasks()
            loop in :tasks ts, t {
                nil
            }
        """)
        val parser = Parser(l)
        val e = parser.exprs()
        assert(e.tostr() == "var ts\nset ts = tasks()\nlopp in :tasks ts, t {\nnil\n}\n") { e.tostr() }
    }
    @Test
    fun tasks2_err() {
        val l = lexer("""
            var ts
            set ts = tasks()
            loop in :tasks ts, 1 {
                nil
            }
        """)
        val parser = Parser(l)
        assert(trap { parser.exprs() } == "anon : (lin 4, col 32) : expected identifier : have \"1\"")
    }
    @Test
    fun tasks3_err() {
        val l = lexer("""
            var ts
            set ts = tasks()
            loop in :tasks x {
                nil
            }
        """)
        val parser = Parser(l)
        assert(trap { parser.exprs() } == "anon : (lin 4, col 30) : expected \",\" : have \"{\"")
    }

    // ITER

    @Test
    fun iter1_err() {
        val l = lexer("""
            loop in 1 {
                nil
            }
        """)
        val parser = Parser(l)
        assert(trap { parser.exprs() } == "anon : (lin 2, col 21) : invalid loop : unexpected 1")
    }
    @Test
    fun iter2_err() {
        val l = lexer("""
            loop in :tasks {
                nil
            }
        """)
        val parser = Parser(l)
        assert(trap { parser.exprs() } == "anon : (lin 2, col 28) : expected expression : have \"{\"")
    }

    // POLY
    /*
    @Test
    fun gg_01_poly_err() {
        val l = lexer("poly x")
        val parser = Parser(l)
        assert(trap { parser.expr() } == "anon : (lin 1, col 6) : poly error : expected var or set")
    }
    @Test
    fun gg_02_poly_err() {
        val l = lexer("poly var x = 1")
        val parser = Parser(l)
        assert(trap { parser.exprs() } == "anon : (lin 1, col 12) : expected expression : have \"=\"")
    }
    @Test
    fun gg_03_poly() {
        val l = lexer("poly var x")
        val parser = Parser(l)
        val e = parser.expr()
        assert(e.tostr(false) == "poly var x") { e.tostr() }
    }
    @Test
    fun gg_04_poly_err() {
        val l = lexer("poly set x = 1")
        val parser = Parser(l)
        assert(trap { parser.exprs() } == "anon : (lin 1, col 14) : expected \"func\" : have \"1\"")
    }
    @Test
    fun gg_05_poly_set_tag() {
        val l = lexer("poly set min :number = 1")
        val parser = Parser(l)
        val e = parser.expr()
        assert(e.tostr(false) == "set min[:number] = 1") { e.tostr() }
    }
    @Test
    fun gg_06_poly_set_func() {
        val l = lexer("poly set f = func () { nil }")
        val parser = Parser(l)
        val e = parser.expr()
        assert(e.tostr(false) == "poly var x") { e.tostr() }
    }
    @Test
    fun gg_07_poly_set_err() {
        val l = lexer("poly set f.x :number = 10")
        val parser = Parser(l)
        val e = parser.expr()
        assert(e.tostr(false) == "poly var x") { e.tostr() }
    }
    */
}
