class TParser {
    // TASKS

    @Ignore // now expands to complex C code
    @Test
    fun tasks1() {
        val l = lexer("""
            var ts
            set ts = tasks()
            loop in :tasks ts, t {
                nil
            }
        """)
        val parser = Parser(l)
        val e = parser.exprs()
        assert(e.tostr() == "var ts\nset ts = tasks()\nlopp in :tasks ts, t {\nnil\n}\n") { e.tostr() }
    }
    @Test
    fun tasks2_err() {
        val l = lexer("""
            var ts
            set ts = tasks()
            loop in :tasks ts, 1 {
                nil
            }
        """)
        val parser = Parser(l)
        assert(trap { parser.exprs() } == "anon : (lin 4, col 32) : expected identifier : have \"1\"")
    }
    @Test
    fun tasks3_err() {
        val l = lexer("""
            var ts
            set ts = tasks()
            loop in :tasks x {
                nil
            }
        """)
        val parser = Parser(l)
        assert(trap { parser.exprs() } == "anon : (lin 4, col 30) : expected \",\" : have \"{\"")
    }

    // ITER

    @Test
    fun iter1_err() {
        val l = lexer("""
            loop in 1 {
                nil
            }
        """)
        val parser = Parser(l)
        assert(trap { parser.exprs() } == "anon : (lin 2, col 21) : invalid loop : unexpected 1")
    }
    @Test
    fun iter2_err() {
        val l = lexer("""
            loop in :tasks {
                nil
            }
        """)
        val parser = Parser(l)
        assert(trap { parser.exprs() } == "anon : (lin 2, col 28) : expected expression : have \"{\"")
    }

    // POLY
    /*
    @Test
    fun gg_01_poly_err() {
        val l = lexer("poly x")
        val parser = Parser(l)
        assert(trap { parser.expr() } == "anon : (lin 1, col 6) : poly error : expected var or set")
    }
    @Test
    fun gg_02_poly_err() {
        val l = lexer("poly var x = 1")
        val parser = Parser(l)
        assert(trap { parser.exprs() } == "anon : (lin 1, col 12) : expected expression : have \"=\"")
    }
    @Test
    fun gg_03_poly() {
        val l = lexer("poly var x")
        val parser = Parser(l)
        val e = parser.expr()
        assert(e.tostr(false) == "poly var x") { e.tostr() }
    }
    @Test
    fun gg_04_poly_err() {
        val l = lexer("poly set x = 1")
        val parser = Parser(l)
        assert(trap { parser.exprs() } == "anon : (lin 1, col 14) : expected \"func\" : have \"1\"")
    }
    @Test
    fun gg_05_poly_set_tag() {
        val l = lexer("poly set min :number = 1")
        val parser = Parser(l)
        val e = parser.expr()
        assert(e.tostr(false) == "set min[:number] = 1") { e.tostr() }
    }
    @Test
    fun gg_06_poly_set_func() {
        val l = lexer("poly set f = func () { nil }")
        val parser = Parser(l)
        val e = parser.expr()
        assert(e.tostr(false) == "poly var x") { e.tostr() }
    }
    @Test
    fun gg_07_poly_set_err() {
        val l = lexer("poly set f.x :number = 10")
        val parser = Parser(l)
        val e = parser.expr()
        assert(e.tostr(false) == "poly var x") { e.tostr() }
    }
    */
}
