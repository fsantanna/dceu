;; is', is-not'

func to-bool (v) {
    not (not v)
}

func is' (v1,v2) {
    ifs {
        (v1 == v2)         -> true
        (type(v2) /= :tag) -> false
        (type(v1) == v2)   -> true
        tags(v1,v2)        -> true
        else -> false
    }
}

func is-not' (v1,v2) {
    not is'(v1,v2)
}

;; ARITHMETIC

export [{+}, {-}, {*}, {**}, {/}, {//}, {%}]
{
    func {+} (v1, v2) {
        if (v1 is-not? :number) or (v2 is-not? :number) {
            throw(:error)
        }
        `:number ($v1.Number + $v2.Number)`
    }

    func {-} (v1, v2) {
        ifs {
            (v1 is? :number) and (v2 is? :nil)           -> `:number (- $v1.Number)`
            (v1 is-not? :number) or (v2 is-not? :number) -> throw(:error)
            else                                         -> `:number ($v1.Number - $v2.Number)`
        }
    }

    func {*} (v1, v2) {
        if (v1 is-not? :number) or (v2 is-not? :number) {
            throw(:error)
        }
        `:number ($v1.Number * $v2.Number)`
    }

    func {**} (v1, v2) {
        if (v1 is-not? :number) or (v2 is-not? :number) {
            throw(:error)
        }
        `:number powf($v1.Number, $v2.Number)`
    }

    func {/} (v1, v2) {
        if (v1 is-not? :number) or (v2 is-not? :number) {
            throw(:error)
        }
        `:number ($v1.Number / $v2.Number)`
    }

    func {//} (v1, v2) {
        if (v1 is-not? :number) or (v2 is-not? :number) {
            throw(:error)
        }
        `:number powf($v1.Number, 1/$v2.Number)`
    }

    func {%} (v1, v2) {
        if (v1 is-not? :number) or (v2 is-not? :number) {
            throw(:error)
        }
        `:number fmod($v1.Number, $v2.Number)`
    }
}

;; RELATIONAL:  >=  >  <=  <

export [{>}, {<}, {>=}, {<=}] {
    func {>} (v1,v2) {
        ifs {
            (v1 is? :tag)    and (v2 is? :tag)    -> `:bool ($v1.Tag    > $v2.Tag)`
            (v1 is? :number) and (v2 is? :number) -> `:bool ($v1.Number > $v2.Number)`
            else -> throw(:error)
        }
    }

    func {<} (v1,v2) {
        not ((v1 == v2) or (v1 > v2))
    }

    func {>=} (v1,v2) {
        (v1 == v2) or (v1 > v2)
    }

    func {<=} (v1,v2) {
        (v1 == v2) or (v1 < v2)
    }
}

;; ASSERT

func assert (v, msg) {
    if not v {
        print("assertion error : ")
        println(msg or "no reason given")
        throw(:assert)
    }
}

;; TAG-OR

func tag-or (t1,t2) {
    assert(type(t1) == :tag)
    assert(type(t2) == :tag)
    `:tag $t1.Tag | $t2.Tag`
}

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; MIN, MAX, BETWEEN
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

func min (v1, v2) {
    ((v1 < v2) and v1) or v2
}

func max (v1, v2) {
    ((v1 > v2) and v1) or v2
}

func between (min_max, v) {
    max(min_max.0, min(min_max.1, v))
}

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; ITERATORS
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

data :Iterator = [f,s,tp,i]

export [iter] {
    func iter-tuple (itr :Iterator) {
        val i = itr.i
        if i >= #itr.s {
            nil
        } else {
            set itr.i = i + 1
            ifs tp = itr.tp {
                tp == :all -> ([i, itr.s[i]])
                tp == :idx -> i
                tp == :val -> itr.s[i]
                else       -> itr.s[i]
            }
        }
    }

    func iter-dict (itr :Iterator) {
        val k = next(itr.s,itr.i)
        if k == nil {
            nil
        } else {
            set itr.i = k
            ifs tp = itr.tp {
                tp == :all -> [k, itr.s[k]]
                tp == :key -> k
                tp == :val -> itr.s[k]
                else       -> k
            }
        }
    }

    func iter-coro (itr :Iterator) {
        val co = itr.s
        val v = resume co()
        ((status(co) /= :terminated) and v) or nil
    }

    func iter (v, tp) {
        ifs v {
            is? :tuple  -> :Iterator [iter-tuple, v, tp, 0]
            is? :vector -> :Iterator [iter-tuple, v, tp, 0]
            is? :dict   -> :Iterator [iter-dict,  v, tp, nil]
            is? :func   -> :Iterator [v]
            is? :x-coro -> :Iterator [iter-coro,  v]
        }
    }
}

;; IN, EQUALS: === =/=

func in' (v, xs) {
    loop in iter(xs), x {
    } until x == v {
    } thus {
        to-bool(it)
    }
}

func :rec {===} (v1,v2) {
    val t1 = type(v1)
    val t2 = type(v2)
    ifs {
        v1 == v2 -> true
        t1 /= t2 -> false
        (t1==:tuple) or (t1==:vector) -> equals-tuple-vector(v1,v2)
        t1 == :dict -> contains-dict?(v1,v2) and contains-dict?(v2,v1)
        else -> false
    } where {
        func equals-tuple-vector (v1, v2) {
            (#v1 == #v2) and not (
                loop in iter(v1,:all), x {
                } while (v2[x.0] === x.1)
            )
        }
        func contains-dict? (v1, v2) {
            not (
                loop in iter(v1,:all), x {
                } while (v2[x.0] === x.1)
            )
        }
     }
}

func :rec {=/=} (v1,v2) {
    not (v1 === v2)
}

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; TO-*
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

func c-to-string (v) {
    assert(type(v) == :pointer)
    val str = #[]
    loop in [0 -> `:number strlen($v.Pointer)`), i {
        set str[+] = `:char ((char*)$v.Pointer)[(int)$i.Number]`
    }
    move(str)
}

func :rec to-string (v) {
    ifs {
        v is? :pointer -> c-to-string(v)
        v is? :tag -> c-to-string(`:pointer ceu_tag_to_string($v.Tag)`)
        v is? :char -> #[v]
        v is? :number -> do {
            ```
            static char str[255];
            snprintf(str, 255, "%g", $v.Number);
            ```
            to-string(`:pointer str`)
        }
        else -> v   ;; TODO
    }
}

func to-number (v) {
    ifs {
        v is? :tag -> `:number $v.Tag`
        ((v is? :vector) and (#v > 0)) and (v[0] is? :char) -> do {
            `:number atoi($v.Dyn->Ncast.Vector.buf)`
        }
        else -> v   ;; TODO
    }
}

func to-vector (v) {
    val ret = #[]
    loop in iter(v), i {
        set ret[+] = i
    }
    move(ret)
}

func to-tracks (...) {
    val ret = #[]
    val args = ...
    loop in iter(args), v {
        ifs {
            v is? :x-task {
                set ret[+] = track(v)
            }
            v is? :x-tasks {
                loop in :tasks v, i {
                    set ret[+] = i
                }
            }
        }
    }
    move(ret)
}

func iterable-to-dict (itb) {
    val dict = @[]
    loop in iter(itb) {
        set dict[it] = true
    }
    move(dict)
}

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CONCAT:  <++  ++
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

func {<++} (v1, v2) {
    assert(type(v1) == :vector)
    assert(type(v2) == :vector)
    do {
        loop in [0 -> #v2), i {
            set v1[+] = v2[i]
        }
    }
    v1
}

func {++} (v1, v2) {
    (#[] <++ v1) <++ v2
}

;; composition

func {<|<} (^f,^g) {
    func (v) {
        ^^f(^^g(v))
    }
}

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; RANDOM:  random-seed  random-next
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

func random-seed (n) {
    if n {
        `srand($n.Number);`
    } else {
        `srand(time(NULL));`
    }
}

func random-next () {
    `:number rand()`
}
