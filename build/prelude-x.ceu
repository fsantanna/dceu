var assert
data :Clock = [ms]

func debug (v) {
    println(v)
    v
}

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; ARITHMETIC: +  -  *  **  /  //  %
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

val ({{+}}, {{-}}, {{*}}, {{**}}, {{/}}, {{//}}, {{%}}) = do {
    func add (v1, v2) {
        if (type(v1) /= :number) or (type(v2) /= :number) {
            error(:error)
        }
        `:number ($v1.Number + $v2.Number)`
    }
    func sub (v1, v2) {
        ifs {
            (type(v1) == :number) and (v2 == nil)          => `:number (- $v1.Number)`
            (type(v1) /= :number) or  (type(v2) /= :number) => error(:error)
            else                                            => `:number ($v1.Number - $v2.Number)`
        }
    }
    func mul (v1, v2) {
        if (type(v1) /= :number) or (type(v2) /= :number) {
            error(:error)
        }
        `:number ($v1.Number * $v2.Number)`
    }
    func exp (v1, v2) {
        if (type(v1) /= :number) or (type(v2) /= :number) {
            error(:error)
        }
        `:number powf($v1.Number, $v2.Number)`
    }
    func div (v1, v2) {
        if (type(v1) /= :number) or (type(v2) /= :number) {
            error(:error)
        }
        `:number ($v1.Number / $v2.Number)`
    }
    func div' (v1, v2) {
        if (type(v1) /= :number) or (type(v2) /= :number) {
            error(:error)
        }
        `:number powf($v1.Number, 1/$v2.Number)`
    }
    func rem (v1, v2) {
        if (type(v1) /= :number) or (type(v2) /= :number) {
            error(:error)
        }
        `:number fmod($v1.Number, $v2.Number)`
    }
    (add, sub, mul, exp, div, div', rem)
}

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; RELATIONAL:  >=  >  <=  <
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

val ({{>}}, {{<}}, {{>=}}, {{<=}}) = do {
    func gt (v1,v2) {
        ifs {
            (type(v1) == :tag)    and (type(v2) == :tag)    => `:bool ($v1.Tag    > $v2.Tag)`
            (type(v1) == :number) and (type(v2) == :number) => `:bool ($v1.Number > $v2.Number)`
            else => error(:error)
        }
    }
    func lt (v1,v2) {
        not ((v1 == v2) or (v1 > v2))
    }
    func gte (v1,v2) {
        (v1 == v2) or (v1 > v2)
    }
    func lte (v1,v2) {
        (v1 == v2) or (v1 < v2)
    }
    (gt, lt, gte, lte)
}

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; ITERATORS: tuple, dict, x-coro, coro, tasks
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

data :Iterator = [f,s,i]
val to-iter = do {
    func iter-tuple (itr :Iterator) {
        val i = itr.i
        if i >= #itr.s {
            nil
        } else {
            set itr.i = i + 1
            (itr.s[i], i)
        }
    }

    func iter-dict (itr :Iterator) {
        val k = next-dict(itr.s,itr.i)
        if k == nil {
            nil
        } else {
            set itr.i = k
            (itr.s[k], k)
        }
    }

    func iter-xcoro (itr :Iterator) {
        val co = itr.s
        (resume co()) --> func (...) {
            if (status(co) == :terminated)
                => nil
                => (...)
        }
    }

    func iter-coro (itr :Iterator) {
        set itr.s = coroutine(itr.s)
        set itr.f = iter-xcoro
        itr.f(itr)
    }

    func iter-tasks (itr :Iterator) {
        ;;error(:TODO)
        set itr.i = next-tasks(itr.s,itr.i)
        itr.i
    }

    func (v) {
        match type(v) {
            ,sup?(:Iterator, tag(v)) => v
            ==:tuple    => :Iterator [iter-tuple, v, 0]
            ==:vector   => :Iterator [iter-tuple, v, 0]
            ==:dict     => :Iterator [iter-dict,  v, nil]
            ==:func     => :Iterator [v]
            ==:coro     => :Iterator [iter-coro, v]
            ==:exe-coro => :Iterator [iter-xcoro, v]
            ==:tasks    => :Iterator [iter-tasks, v, nil, nil]
            else        => nil
        }
    }
}

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; === =/=
;; IS, IS-NOT
;; IN, IN-NOT
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

val ({{===}}, {{=/=}}) = do {
    func eq (v1,v2) {
        val t1 = type(v1)
        val t2 = type(v2)
        ifs {
            v1 == v2 => true
            t1 /= t2 => false
            (t1==:tuple) or (t1==:vector) => equals-tuple-vector(v1,v2)
            t1 == :dict => contains-dict?(v1,v2) and contains-dict?(v2,v1)
            else => false
        } where {
            func equals-tuple-vector (v1', v2') {
                (#v1' == #v2') and not (
                    loop (v,i) in v1' {
                        while (v2'[i] === v)
                    }
                )
            }
            func contains-dict? (v1', v2') {
                not (
                    loop (v,k) in v1' {
                        while (v2'[k] === v)
                    }
                )
            }
         }
    }
    func neq (v1,v2) {
        not (v1 === v2)
    }
    (eq, neq)
}

val (is', is-not') = do {
    func x-is (v1,v2) {
        ifs {
            (v1 === v2)        => true
            (type(v1) == v2)   => true
            (type(v2) == :tag) => sup?(v2, tag(v1))
            else => false
        }
    }
    func x-is-not (v1,v2) {
        not is'(v1,v2)
    }
    (x-is, x-is-not)
}

val (in', in-not') = do {
    func x-in (v, xs) {
        if (type(xs) == :dict) and xs[v] { ,it =>
            it
        } else {
            loop (b,a) in xs {
                until match xs {
                    :dict   => (v === a) and b
                    :tuple  => (v === b) and b
                    :vector => (v === b) and b
                    else    => (v === a) and a
                }
            }
        }
    }
    func x-in-not (v, xs) {
        not in'(v,xs)
    }
    (x-in, x-in-not)
}

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; TODO
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

func tag-or (t1,t2) {
    assert(type(t1) == :tag)
    assert(type(t2) == :tag)
    `:tag $t1.Tag | $t2.Tag`
}

func string? (v) {
    ((type(v)==:vector) and (#v>0)) and (type(v[0])==:char)
}

func next (v, ...) {
    match v {
        :exe-coro => resume v(...)
        :tasks    => next-tasks(v, ...)
        :dict     => next-dict(v, ...)
        :Iterator => it.f(v)
        else      => error(:error)
    }
}

func create-resume (CO, ...) {
    val co = coroutine(CO)
    assert(resume co(...) == nil)
    co
}

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; TO: string, bool, char, number, tag, pointer, iter
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

data :To = [string, bool, char, number, tag, pointer, iter]

val to :To = do {
    func to-string (v) {
        match v {
            {{string?}} => v
            :nil        => "nil"
            :tag        => to-string-tag(v)
            :number     => to-string-number(v)
            :char       => #[v]
            :pointer    => to-string-pointer(v)
            else        => nil
        }
    }
    func to-bool (v) {
        not (not v)
    }
    func to-char (v) {
        match v {
            :char   => v
            :number => `:char $v.Number`
            {{string?}} {
                ifs {
                    (#v == 1) => v[0]
                    (#v /= 2) => nil
                    (v[0] /= '\\') => nil
                    else {
                        val t = @[
                            ("\\a", '\a'),
                            ("\\b", '\b'),
                            ("\\f", '\f'),
                            ("\\n", '\n'),
                            ("\\r", '\r'),
                            ("\\t", '\t'),
                            ("\\v", '\v'),
                            ("\\'", '\''),
                            ("\\\"", '\"'),
                            ("\\?", '\?'),
                            ("\\\\", '\\'),
                        ]
                        v in? t
                    }
                }
            }
            else => nil
        }
    }
    func to-number (v) {
        match v {
            :tag        => `:number $v.Tag`
            :char       => `:number $v.Char`
            {{string?}} => `:number atoi($v.Dyn->Vector.buf)`
            else        => nil
        }
    }
    func to-tag (v) {
        match v {
            :tag        => v
            {{string?}} => to-tag-string(v)
            else        => nil
        }
    }
    func to-pointer (v) {
        match v {
            :pointer => v
            :tag     => `:pointer ceu_to_dash_string_dash_tag($v.Tag)`
            :tuple   => `:pointer $v.Dyn->Tuple.buf`
            :vector  => `:pointer $v.Dyn->Vector.buf`
            :dict    => `:pointer $v.Dyn->Dict.buf`
            else     => nil
        }
    }
    [to-string, to-bool, to-char, to-number, to-tag, to-pointer, to-iter]
}

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; TYPE-*
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

func type-static? (v) {
    to.number(v) < `:number CEU_VALUE_DYNAMIC`
}
func type-dynamic? (v) {
    to.number(v) > `:number CEU_VALUE_DYNAMIC`
}

;; COPY

func copy (v) {
    match type(v) {
        {{type-static?}} {
            v
        }
        :tuple {
            val ret = tuple(#v)
            loop i in {0 => #v{ {
                set ret[i] = copy(v[i])
            }
            ret
        }
        :vector {
            val ret = #[]
            loop i in {0 => #v{ {
                set ret[i] = copy(v[i])
            }
            ret
        }
        :dict {
            val ret = @[]
            var k = nil
            loop {
                set k = next-dict(v, k)
                until (k == nil)
                set ret[copy(k)] = copy(v[k])
            }
            ret
        }
        else {
            error(:TODO)
        }
    }
}

func to-tuple (col) {
    match col {
        :tuple => col
        :vector {
            val tup = tuple(#col)
            loop (v,i) in col {
                set tup[i] = v
            }
            tup
        }
        else => error(:TODO)
    }
}

func to-vector (col) {
    val ret = #[]
    loop v in col {
        set ret[+] = v
    }
    ret
}

func to-dict (col) {
    val ret = @[]
    loop v in col {
        set ret[v[0]] = v[1]
    }
    ret
}

;;;
func to-tasks (...) {
    val ret = #[]
    val args = ...
    loop v in args {
        match v {
            :exe-task {
                set ret[+] = v
            }
            :tasks {
                loop i in v {
                    set ret[+] = i
                }
            }
        }
    }
    ret
}
;;;

func to-set (col) {
    val ret = @[]
    loop in col {
        set ret[it] = true
    }
    ret
}

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CONCAT:  <++  ++
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

func {{<++}} (v1, v2) {
    assert(type(v1) == :vector)
    assert(type(v2) == :vector)
    do {
        loop i in {0 => #v2{ {
            set v1[+] = v2[i]
        }
    }
    v1
}

func {{++}} (v1, v2) {
    (#[] <++ v1) <++ v2
}

;; composition

func {{<|<}} (f,g) {
    func (v) {
        f(g(v))
    }
}

;; ASSERT

set assert = func (v, msg) {
    ifs {
        v => v
        (type(msg) == :func) => error(msg())
        msg->string? => error("assertion error : " ++ msg)
        (msg == nil) => error("assertion error")
        else => error(msg)
    }
}

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; RANDOM: seed, next
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

data :Random = [seed,next]

val random :Random = do {
    func x-seed (n) {
        if n {
            `srand($n.Number);`
        } else {
            `srand(time(NULL));`
        }
    }
    func x-next () {
        `:number rand()`
    }
    [x-seed, x-next]
}

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; MATH: sin,cos,floor , min,max,between
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

data :Math = [
    PI, sin, cos,
    floor, ceil, round,
    min, max, between,
]

val math :Math = do {
    val PI = `:number M_PI`
    func sin (v) {
        `:number sin($v.Number)`
    }
    func cos (v) {
        `:number cos($v.Number)`
    }

    func floor (v) {
        `:number floor($v.Number)`
    }
    func ceil (v) {
        `:number ceil($v.Number)`
    }
    func round (v) {
        `:number round($v.Number)`
    }

    func min (v1, v2) {
        ((v1 < v2) and v1) or v2
    }
    func max (v1, v2) {
        ((v1 > v2) and v1) or v2
    }
    ;; TODO
    ;; func between (v, [min,max]) {
    func between (v, min_max) {
        max(min_max[0], min(v, min_max[1]))
    }

    [PI,sin,cos , floor,ceil,round , min,max,between]
}
